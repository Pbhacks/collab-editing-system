{"ast":null,"code":"// Attempts to use STOMP over SockJS for realtime edits.\n// If connect fails, consumers should fall back to polling.\n\nimport SockJS from \"sockjs-client\";\nimport Stomp from \"stompjs\";\nlet stompClient = null;\n\n/**\r\n * Try to connect to /ws endpoint at doc-service.\r\n * onMessage is called with parsed message object from server.\r\n * Returns a promise that resolves to an object {connected, disconnect}\r\n */\nexport function connectWebSocket(docId, onMessage, onConnect) {\n  return new Promise(resolve => {\n    try {\n      const socket = new SockJS(\"http://localhost:8082/ws\");\n      stompClient = Stomp.over(socket);\n      // disable debug logs\n      stompClient.debug = null;\n      stompClient.connect({}, () => {\n        // subscribe to a topic for this document\n        const sub = stompClient.subscribe(`/topic/document/${docId}`, msg => {\n          if (msg.body) {\n            try {\n              onMessage(JSON.parse(msg.body));\n            } catch (e) {/* ignore */}\n          }\n        });\n        if (onConnect) onConnect();\n        resolve({\n          connected: true,\n          disconnect: () => {\n            try {\n              sub.unsubscribe();\n            } catch (e) {}\n            try {\n              stompClient.disconnect();\n            } catch (e) {}\n          }\n        });\n      }, err => {\n        // connection failed\n        resolve({\n          connected: false,\n          disconnect: () => {}\n        });\n      });\n    } catch (e) {\n      resolve({\n        connected: false,\n        disconnect: () => {}\n      });\n    }\n  });\n}\n\n/**\r\n * Send edit via STOMP to server path e.g. /app/edit/{docId}\r\n * Server must map this endpoint. If not available, client should call REST PUT.\r\n */\nexport function sendEditViaWS(docId, payload) {\n  if (!stompClient) return false;\n  try {\n    stompClient.send(`/app/edit/${docId}`, {}, JSON.stringify(payload));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","map":{"version":3,"names":["SockJS","Stomp","stompClient","connectWebSocket","docId","onMessage","onConnect","Promise","resolve","socket","over","debug","connect","sub","subscribe","msg","body","JSON","parse","e","connected","disconnect","unsubscribe","err","sendEditViaWS","payload","send","stringify"],"sources":["C:/Users/Admin/Desktop/collab-editing-system/frontend/src/websocket.js"],"sourcesContent":["// Attempts to use STOMP over SockJS for realtime edits.\r\n// If connect fails, consumers should fall back to polling.\r\n\r\nimport SockJS from \"sockjs-client\";\r\nimport Stomp from \"stompjs\";\r\n\r\nlet stompClient = null;\r\n\r\n/**\r\n * Try to connect to /ws endpoint at doc-service.\r\n * onMessage is called with parsed message object from server.\r\n * Returns a promise that resolves to an object {connected, disconnect}\r\n */\r\nexport function connectWebSocket(docId, onMessage, onConnect) {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      const socket = new SockJS(\"http://localhost:8082/ws\");\r\n      stompClient = Stomp.over(socket);\r\n      // disable debug logs\r\n      stompClient.debug = null;\r\n      stompClient.connect({}, () => {\r\n        // subscribe to a topic for this document\r\n        const sub = stompClient.subscribe(`/topic/document/${docId}`, (msg) => {\r\n          if (msg.body) {\r\n            try { onMessage(JSON.parse(msg.body)); } catch(e) { /* ignore */ }\r\n          }\r\n        });\r\n\r\n        if (onConnect) onConnect();\r\n\r\n        resolve({\r\n          connected: true,\r\n          disconnect: () => {\r\n            try { sub.unsubscribe(); } catch(e) {}\r\n            try { stompClient.disconnect(); } catch(e) {}\r\n          }\r\n        });\r\n      }, (err) => {\r\n        // connection failed\r\n        resolve({ connected: false, disconnect: () => {} });\r\n      });\r\n    } catch (e) {\r\n      resolve({ connected: false, disconnect: () => {} });\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Send edit via STOMP to server path e.g. /app/edit/{docId}\r\n * Server must map this endpoint. If not available, client should call REST PUT.\r\n */\r\nexport function sendEditViaWS(docId, payload) {\r\n  if (!stompClient) return false;\r\n  try {\r\n    stompClient.send(`/app/edit/${docId}`, {}, JSON.stringify(payload));\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;;AAEA,OAAOA,MAAM,MAAM,eAAe;AAClC,OAAOC,KAAK,MAAM,SAAS;AAE3B,IAAIC,WAAW,GAAG,IAAI;;AAEtB;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACC,KAAK,EAAEC,SAAS,EAAEC,SAAS,EAAE;EAC5D,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;IAC9B,IAAI;MACF,MAAMC,MAAM,GAAG,IAAIT,MAAM,CAAC,0BAA0B,CAAC;MACrDE,WAAW,GAAGD,KAAK,CAACS,IAAI,CAACD,MAAM,CAAC;MAChC;MACAP,WAAW,CAACS,KAAK,GAAG,IAAI;MACxBT,WAAW,CAACU,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM;QAC5B;QACA,MAAMC,GAAG,GAAGX,WAAW,CAACY,SAAS,CAAC,mBAAmBV,KAAK,EAAE,EAAGW,GAAG,IAAK;UACrE,IAAIA,GAAG,CAACC,IAAI,EAAE;YACZ,IAAI;cAAEX,SAAS,CAACY,IAAI,CAACC,KAAK,CAACH,GAAG,CAACC,IAAI,CAAC,CAAC;YAAE,CAAC,CAAC,OAAMG,CAAC,EAAE,CAAE;UACtD;QACF,CAAC,CAAC;QAEF,IAAIb,SAAS,EAAEA,SAAS,CAAC,CAAC;QAE1BE,OAAO,CAAC;UACNY,SAAS,EAAE,IAAI;UACfC,UAAU,EAAEA,CAAA,KAAM;YAChB,IAAI;cAAER,GAAG,CAACS,WAAW,CAAC,CAAC;YAAE,CAAC,CAAC,OAAMH,CAAC,EAAE,CAAC;YACrC,IAAI;cAAEjB,WAAW,CAACmB,UAAU,CAAC,CAAC;YAAE,CAAC,CAAC,OAAMF,CAAC,EAAE,CAAC;UAC9C;QACF,CAAC,CAAC;MACJ,CAAC,EAAGI,GAAG,IAAK;QACV;QACAf,OAAO,CAAC;UAAEY,SAAS,EAAE,KAAK;UAAEC,UAAU,EAAEA,CAAA,KAAM,CAAC;QAAE,CAAC,CAAC;MACrD,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOF,CAAC,EAAE;MACVX,OAAO,CAAC;QAAEY,SAAS,EAAE,KAAK;QAAEC,UAAU,EAAEA,CAAA,KAAM,CAAC;MAAE,CAAC,CAAC;IACrD;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASG,aAAaA,CAACpB,KAAK,EAAEqB,OAAO,EAAE;EAC5C,IAAI,CAACvB,WAAW,EAAE,OAAO,KAAK;EAC9B,IAAI;IACFA,WAAW,CAACwB,IAAI,CAAC,aAAatB,KAAK,EAAE,EAAE,CAAC,CAAC,EAAEa,IAAI,CAACU,SAAS,CAACF,OAAO,CAAC,CAAC;IACnE,OAAO,IAAI;EACb,CAAC,CAAC,OAAON,CAAC,EAAE;IACV,OAAO,KAAK;EACd;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}